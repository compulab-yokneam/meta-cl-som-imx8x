From 8989fb525e1ebcdf75f41f3946290ab30bbbd63d Mon Sep 17 00:00:00 2001
From: Igor Derzhavets <igor.derzhavets@compulab.co.il>
Date: Thu, 1 Aug 2019 15:25:34 +0300
Subject: [PATCH 10/11] cl-som-imx8x: Add CL-SOM-iMX8X board to U-Boot

Signed-off-by: Igor Derzhavets <igor.derzhavets@compulab.co.il>
---
 arch/arm/dts/Makefile                        |   2 +
 arch/arm/dts/cl-som-imx8x.dts                | 335 +++++++++++++++++++
 arch/arm/mach-imx/imx8/Kconfig               |   7 +
 board/compulab/cl-som-imx8x/Kconfig          |  12 +
 board/compulab/cl-som-imx8x/Makefile         |  10 +
 board/compulab/cl-som-imx8x/cl-som-imx8x.c   | 465 +++++++++++++++++++++++++++
 board/compulab/cl-som-imx8x/cl-som-imx8x.cfg |  14 +
 board/compulab/cl-som-imx8x/spl.c            |  54 ++++
 configs/cl-som-imx8x_defconfig               | 168 ++++++++++
 include/configs/cl-som-imx8x.h               | 267 +++++++++++++++
 10 files changed, 1334 insertions(+)
 create mode 100644 arch/arm/dts/cl-som-imx8x.dts
 create mode 100644 board/compulab/cl-som-imx8x/Kconfig
 create mode 100644 board/compulab/cl-som-imx8x/Makefile
 create mode 100644 board/compulab/cl-som-imx8x/cl-som-imx8x.c
 create mode 100644 board/compulab/cl-som-imx8x/cl-som-imx8x.cfg
 create mode 100644 board/compulab/cl-som-imx8x/spl.c
 create mode 100644 configs/cl-som-imx8x_defconfig
 create mode 100644 include/configs/cl-som-imx8x.h

diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 0d24acd457..2eeb0b5482 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -781,6 +781,8 @@ dtb-$(CONFIG_ARCH_IMX8) += \
 	imx8-deneb.dtb \
 	imx8-giedi.dtb
 
+dtb-$(CONFIG_TARGET_CL_SOM_IMX8X) += cl-som-imx8x.dtb
+
 dtb-$(CONFIG_ARCH_IMX8M) += \
 	imx8mm-evk.dtb \
 	imx8mm-evk-qca-wifi.dtb \
diff --git a/arch/arm/dts/cl-som-imx8x.dts b/arch/arm/dts/cl-som-imx8x.dts
new file mode 100644
index 0000000000..8691d67151
--- /dev/null
+++ b/arch/arm/dts/cl-som-imx8x.dts
@@ -0,0 +1,335 @@
+/*
+ * Copyright 2019 Compulab
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "fsl-imx8qxp.dtsi"
+
+/ {
+	model = "CompuLab CL-SOM-iMX8X";
+	compatible = "fsl,imx8qxp-mek", "fsl,imx8qxp";
+
+	chosen {
+		bootargs = "console=ttyLP0,115200 earlycon";
+		stdout-path = &lpuart0;
+	};
+
+	usbh3: usbh3 {
+		compatible = "Cadence,usb3-host";
+		dr_mode = "host";
+		cdns3,usb = <&usbotg3>;
+		status = "okay";
+	};
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_usdhc2_vmmc: regulator-usdhc2-vmmc {
+			compatible = "regulator-fixed";
+			regulator-name = "SD1_SPWR";
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3000000>;
+			gpio = <&gpio4 19 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+			off-on-delay-us = <3480>;
+		};
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	cl-som-imx8x {
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				SC_P_MCLK_OUT0_ADMA_ACM_MCLK_OUT0       0x0600004c
+				SC_P_COMP_CTL_GPIO_1V8_3V3_GPIORHB_PAD	0x000514a0
+			>;
+		};
+
+		pinctrl_fec1: fec1grp {
+			fsl,pins = <
+				SC_P_COMP_CTL_GPIO_1V8_3V3_ENET_ENETB0_PAD	0x000014a0
+				SC_P_COMP_CTL_GPIO_1V8_3V3_ENET_ENETB1_PAD	0x000014a0
+				SC_P_ENET0_MDC_CONN_ENET0_MDC			0x06000020
+				SC_P_ENET0_MDIO_CONN_ENET0_MDIO			0x06000020
+				SC_P_ENET0_RGMII_TX_CTL_CONN_ENET0_RGMII_TX_CTL 0x00000061
+			>;
+		};
+
+		pinctrl_fec2: fec2grp {
+			fsl,pins = <
+				SC_P_ESAI0_SCKR_CONN_ENET1_RGMII_TX_CTL		0x00000060
+				SC_P_ESAI0_FSR_CONN_ENET1_RGMII_TXC		0x00000060
+				SC_P_ESAI0_TX4_RX1_CONN_ENET1_RGMII_TXD0	0x00000060
+				SC_P_ESAI0_TX5_RX0_CONN_ENET1_RGMII_TXD1	0x00000060
+				SC_P_ESAI0_FST_CONN_ENET1_RGMII_TXD2		0x00000060
+				SC_P_ESAI0_SCKT_CONN_ENET1_RGMII_TXD3		0x00000060
+				SC_P_ESAI0_TX0_CONN_ENET1_RGMII_RXC		0x00000060
+				SC_P_SPDIF0_TX_CONN_ENET1_RGMII_RX_CTL		0x00000060
+				SC_P_SPDIF0_RX_CONN_ENET1_RGMII_RXD0		0x00000060
+				SC_P_ESAI0_TX3_RX2_CONN_ENET1_RGMII_RXD1	0x00000060
+				SC_P_ESAI0_TX2_RX3_CONN_ENET1_RGMII_RXD2	0x00000060
+				SC_P_ESAI0_TX1_CONN_ENET1_RGMII_RXD3		0x00000060
+			>;
+		};
+
+		pinctrl_lpi2c1: lpi2c1grp {
+			fsl,pins = <
+				SC_P_USB_SS3_TC1_ADMA_I2C1_SCL	0x06000021
+				SC_P_USB_SS3_TC3_ADMA_I2C1_SDA	0x06000021
+			>;
+		};
+
+		pinctrl_lpuart0: lpuart0grp {
+			fsl,pins = <
+				SC_P_UART0_RX_ADMA_UART0_RX	0x06000020
+				SC_P_UART0_TX_ADMA_UART0_TX	0x06000020
+			>;
+		};
+
+		pinctrl_usdhc1: usdhc1grp {
+			fsl,pins = <
+				SC_P_EMMC0_CLK_CONN_EMMC0_CLK		0x06000041
+				SC_P_EMMC0_CMD_CONN_EMMC0_CMD		0x00000021
+				SC_P_EMMC0_DATA0_CONN_EMMC0_DATA0	0x00000021
+				SC_P_EMMC0_DATA1_CONN_EMMC0_DATA1	0x00000021
+				SC_P_EMMC0_DATA2_CONN_EMMC0_DATA2	0x00000021
+				SC_P_EMMC0_DATA3_CONN_EMMC0_DATA3	0x00000021
+				SC_P_EMMC0_DATA4_CONN_EMMC0_DATA4	0x00000021
+				SC_P_EMMC0_DATA5_CONN_EMMC0_DATA5	0x00000021
+				SC_P_EMMC0_DATA6_CONN_EMMC0_DATA6	0x00000021
+				SC_P_EMMC0_DATA7_CONN_EMMC0_DATA7	0x00000021
+				SC_P_EMMC0_STROBE_CONN_EMMC0_STROBE	0x00000041
+			>;
+		};
+
+		pinctrl_usdhc2_gpio: usdhc2gpiogrp {
+			fsl,pins = <
+				SC_P_USDHC1_RESET_B_LSIO_GPIO4_IO19	0x00000021
+				SC_P_USDHC1_WP_LSIO_GPIO4_IO21		0x00000021
+				SC_P_USDHC1_CD_B_LSIO_GPIO4_IO22	0x00000021
+			>;
+		};
+
+		pinctrl_usdhc2: usdhc2grp {
+			fsl,pins = <
+				SC_P_USDHC1_CLK_CONN_USDHC1_CLK		0x06000041
+				SC_P_USDHC1_CMD_CONN_USDHC1_CMD		0x00000021
+				SC_P_USDHC1_DATA0_CONN_USDHC1_DATA0	0x00000021
+				SC_P_USDHC1_DATA1_CONN_USDHC1_DATA1	0x00000021
+				SC_P_USDHC1_DATA2_CONN_USDHC1_DATA2	0x00000021
+				SC_P_USDHC1_DATA3_CONN_USDHC1_DATA3	0x00000021
+				SC_P_USDHC1_VSELECT_CONN_USDHC1_VSELECT	0x00000021
+			>;
+		};
+
+		pinctrl_pcieb: pcieagrp{
+			fsl,pins = <
+				SC_P_PCIE_CTRL0_PERST_B_LSIO_GPIO4_IO00		0x06000021
+				SC_P_PCIE_CTRL0_CLKREQ_B_LSIO_GPIO4_IO01	0x06000021
+				SC_P_PCIE_CTRL0_WAKE_B_LSIO_GPIO4_IO02		0x04000021
+			>;
+		};
+
+		pinctrl_flexspi0: flexspi0grp {
+			fsl,pins = <
+				SC_P_QSPI0A_DATA0_LSIO_QSPI0A_DATA0	0x06000021
+				SC_P_QSPI0A_DATA1_LSIO_QSPI0A_DATA1	0x06000021
+				SC_P_QSPI0A_DATA2_LSIO_QSPI0A_DATA2	0x06000021
+				SC_P_QSPI0A_DATA3_LSIO_QSPI0A_DATA3	0x06000021
+				SC_P_QSPI0A_DQS_LSIO_QSPI0A_DQS		0x06000021
+				SC_P_QSPI0A_SS0_B_LSIO_QSPI0A_SS0_B	0x06000021
+				SC_P_QSPI0A_SS1_B_LSIO_QSPI0A_SS1_B	0x06000021
+				SC_P_QSPI0A_SCLK_LSIO_QSPI0A_SCLK	0x06000021
+				SC_P_QSPI0B_SCLK_LSIO_QSPI0B_SCLK	0x06000021
+				SC_P_QSPI0B_DATA0_LSIO_QSPI0B_DATA0	0x06000021
+				SC_P_QSPI0B_DATA1_LSIO_QSPI0B_DATA1	0x06000021
+				SC_P_QSPI0B_DATA2_LSIO_QSPI0B_DATA2	0x06000021
+				SC_P_QSPI0B_DATA3_LSIO_QSPI0B_DATA3	0x06000021
+				SC_P_QSPI0B_DQS_LSIO_QSPI0B_DQS		0x06000021
+				SC_P_QSPI0B_SS0_B_LSIO_QSPI0B_SS0_B	0x06000021
+				SC_P_QSPI0B_SS1_B_LSIO_QSPI0B_SS1_B	0x06000021
+			>;
+		};
+	};
+};
+
+&A35_0 {
+	u-boot,dm-pre-reloc;
+};
+
+&lpuart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_lpuart0>;
+	u-boot,dm-spl;
+	status = "okay";
+};
+
+&flexspi0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexspi0>;
+	status = "okay";
+	u-boot,dm-spl;
+
+	flash0: mt35xu512aba@0 {
+		reg = <0>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "spi-flash";
+		spi-max-frequency = <29000000>;
+		spi-nor,ddr-quad-read-dummy = <8>;
+		u-boot,dm-spl;
+	};
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_lpi2c1>;
+	status = "okay";
+};
+
+&usdhc1 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	pinctrl-1 = <&pinctrl_usdhc1>;
+	pinctrl-2 = <&pinctrl_usdhc1>;
+	bus-width = <8>;
+	non-removable;
+	mmc-hs400-1_8v;
+	u-boot,dm-spl;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-1 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-2 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	bus-width = <4>;
+	cd-gpios = <&gpio4 22 GPIO_ACTIVE_LOW>;
+	wp-gpios = <&gpio4 21 GPIO_ACTIVE_HIGH>;
+	vmmc-supply = <&reg_usdhc2_vmmc>;
+	u-boot,dm-spl;
+	sd-uhs-sdr104;
+	sd-uhs-ddr50;
+	status = "okay";
+};
+
+&pcieb{
+	ext_osc = <1>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcieb>;
+	clkreq-gpio = <&gpio4 1 GPIO_ACTIVE_LOW>;
+	reset-gpio = <&gpio4 0 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&fec1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_fec1>;
+	phy-mode = "rgmii";
+	phy-handle = <&ethphy0>;
+	fsl,ar8031-phy-fixup;
+	fsl,magic-packet;
+	phy-reset-gpios = <&gpio3 23 GPIO_ACTIVE_LOW>;
+	phy-reset-duration = <10>;
+	phy-reset-post-delay = <150>;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@0 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <0>;
+		};
+		ethphy1: ethernet-phy@1 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <1>;
+		};
+	};
+};
+
+&fec2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_fec2>;
+	phy-mode = "rgmii";
+	phy-handle = <&ethphy1>;
+	fsl,ar8031-phy-fixup;
+	fsl,magic-packet;
+	phy-reset-gpios = <&gpio3 22 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&usbotg1 {
+	srp-disable;
+	hnp-disable;
+	adp-disable;
+	power-polarity-active-high;
+	disable-over-current;
+	u-boot,dm-spl;
+	status = "okay";
+};
+
+&usbotg3 {
+	phys = <&usbphynop1>;
+	u-boot,dm-spl;
+	status = "okay";
+};
+
+&usbphynop1 {
+	compatible = "cdns,usb3-phy";
+	reg = <0x0 0x5B160000 0x0 0x40000>;
+	#phy-cells = <0>;
+	u-boot,dm-spl;
+};
+
+&{/imx8qx-pm} {
+
+	u-boot,dm-spl;
+};
+
+&mu {
+	u-boot,dm-spl;
+};
+
+&clk {
+	u-boot,dm-spl;
+};
+
+&pd_lsio {
+	u-boot,dm-spl;
+};
+
+&pd_conn {
+	u-boot,dm-spl;
+};
+
+&pd_conn_sdch1 {
+	u-boot,dm-spl;
+};
+
+&pd_dma {
+	u-boot,dm-spl;
+};
+
+&pd_lsio_flexspi0 {
+	u-boot,dm-spl;
+};
diff --git a/arch/arm/mach-imx/imx8/Kconfig b/arch/arm/mach-imx/imx8/Kconfig
index f6ead7218d..6ceb41c5ab 100644
--- a/arch/arm/mach-imx/imx8/Kconfig
+++ b/arch/arm/mach-imx/imx8/Kconfig
@@ -117,6 +117,12 @@ config TARGET_IMX8QM_MEK
 	select BOARD_LATE_INIT
 	select IMX8QM
 
+config TARGET_CL_SOM_IMX8X
+	bool "Support CompuLab cl-som-imx8x"
+	select BOARD_LATE_INIT
+	select SUPPORT_SPL
+	select IMX8QXP
+
 config TARGET_IMX8QM_LPDDR4_VAL
 	bool "Support i.MX8QM lpddr4 validation board"
 	select BOARD_LATE_INIT
@@ -186,6 +192,7 @@ source "board/advantech/imx8qm_rom7720_a1/Kconfig"
 source "board/toradex/apalis-imx8/Kconfig"
 source "board/toradex/colibri-imx8x/Kconfig"
 source "board/siemens/capricorn/Kconfig"
+source "board/compulab/cl-som-imx8x/Kconfig"
 
 config SNVS_SEC_SC
 	bool "Support SNVS configuration"
diff --git a/board/compulab/cl-som-imx8x/Kconfig b/board/compulab/cl-som-imx8x/Kconfig
new file mode 100644
index 0000000000..b1f96badf1
--- /dev/null
+++ b/board/compulab/cl-som-imx8x/Kconfig
@@ -0,0 +1,12 @@
+if TARGET_CL_SOM_IMX8X
+
+config SYS_BOARD
+	default "cl-som-imx8x"
+
+config SYS_VENDOR
+	default "compulab"
+
+config SYS_CONFIG_NAME
+	default "cl-som-imx8x"
+
+endif
diff --git a/board/compulab/cl-som-imx8x/Makefile b/board/compulab/cl-som-imx8x/Makefile
new file mode 100644
index 0000000000..41a859a374
--- /dev/null
+++ b/board/compulab/cl-som-imx8x/Makefile
@@ -0,0 +1,10 @@
+#
+# Copyright 2019 CompuLab
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+obj-y += cl-som-imx8x.o
+
+ifdef CONFIG_SPL_BUILD
+obj-y += spl.o
+endif
diff --git a/board/compulab/cl-som-imx8x/cl-som-imx8x.c b/board/compulab/cl-som-imx8x/cl-som-imx8x.c
new file mode 100644
index 0000000000..17a7682b97
--- /dev/null
+++ b/board/compulab/cl-som-imx8x/cl-som-imx8x.c
@@ -0,0 +1,465 @@
+/*
+ * Copyright 2019 CompuLab
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <cpu_func.h>
+#include <env.h>
+#include <errno.h>
+#include <init.h>
+#include <linux/libfdt.h>
+#include <fsl_esdhc.h>
+#include <netdev.h>
+#include <fdt_support.h>
+#include <bootm.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/sci/sci.h>
+#include <asm/arch/imx8-pins.h>
+#include <asm/arch/snvs_security_sc.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <usb.h>
+#include <power-domain.h>
+#include "../common/eeprom.h"
+
+
+#define ESDHC_PAD_CTRL	((SC_PAD_CONFIG_NORMAL << PADRING_CONFIG_SHIFT) | (SC_PAD_ISO_OFF << PADRING_LPCONFIG_SHIFT) \
+						| (SC_PAD_28FDSOI_DSE_DV_HIGH << PADRING_DSE_SHIFT) | (SC_PAD_28FDSOI_PS_PU << PADRING_PULL_SHIFT))
+
+#define ESDHC_CLK_PAD_CTRL	((SC_PAD_CONFIG_OUT_IN << PADRING_CONFIG_SHIFT) | (SC_PAD_ISO_OFF << PADRING_LPCONFIG_SHIFT) \
+						| (SC_PAD_28FDSOI_DSE_DV_HIGH << PADRING_DSE_SHIFT) | (SC_PAD_28FDSOI_PS_PU << PADRING_PULL_SHIFT))
+
+
+#define ENET_INPUT_PAD_CTRL	((SC_PAD_CONFIG_OD_IN << PADRING_CONFIG_SHIFT) | (SC_PAD_ISO_OFF << PADRING_LPCONFIG_SHIFT) \
+						| (SC_PAD_28FDSOI_DSE_DV_HIGH << PADRING_DSE_SHIFT) | (SC_PAD_28FDSOI_PS_PU << PADRING_PULL_SHIFT))
+
+#define ENET_NORMAL_PAD_CTRL	((SC_PAD_CONFIG_NORMAL << PADRING_CONFIG_SHIFT) | (SC_PAD_ISO_OFF << PADRING_LPCONFIG_SHIFT) \
+						| (SC_PAD_28FDSOI_DSE_DV_HIGH << PADRING_DSE_SHIFT) | (SC_PAD_28FDSOI_PS_PU << PADRING_PULL_SHIFT))
+
+#define FSPI_PAD_CTRL	((SC_PAD_CONFIG_NORMAL << PADRING_CONFIG_SHIFT) | (SC_PAD_ISO_OFF << PADRING_LPCONFIG_SHIFT) \
+						| (SC_PAD_28FDSOI_DSE_DV_HIGH << PADRING_DSE_SHIFT) | (SC_PAD_28FDSOI_PS_PU << PADRING_PULL_SHIFT))
+
+#define GPIO_PAD_CTRL	((SC_PAD_CONFIG_NORMAL << PADRING_CONFIG_SHIFT) | (SC_PAD_ISO_OFF << PADRING_LPCONFIG_SHIFT) \
+						| (SC_PAD_28FDSOI_DSE_DV_HIGH << PADRING_DSE_SHIFT) | (SC_PAD_28FDSOI_PS_PU << PADRING_PULL_SHIFT))
+
+#define I2C_PAD_CTRL	((SC_PAD_CONFIG_OUT_IN << PADRING_CONFIG_SHIFT) | (SC_PAD_ISO_OFF << PADRING_LPCONFIG_SHIFT) \
+						| (SC_PAD_28FDSOI_DSE_DV_LOW << PADRING_DSE_SHIFT) | (SC_PAD_28FDSOI_PS_PU << PADRING_PULL_SHIFT))
+
+#define UART_PAD_CTRL	((SC_PAD_CONFIG_OUT_IN << PADRING_CONFIG_SHIFT) | (SC_PAD_ISO_OFF << PADRING_LPCONFIG_SHIFT) \
+						| (SC_PAD_28FDSOI_DSE_DV_HIGH << PADRING_DSE_SHIFT) | (SC_PAD_28FDSOI_PS_PU << PADRING_PULL_SHIFT))
+
+static uchar cl_som_imx8x_eeprom_buf[CONFIG_SYS_EEPROM_SIZE];
+static struct eeprom_layout cl_som_imx8x_layout;
+
+static iomux_cfg_t uart0_pads[] = {
+	SC_P_UART0_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	SC_P_UART0_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static void setup_iomux_uart(void)
+{
+	imx8_iomux_setup_multiple_pads(uart0_pads, ARRAY_SIZE(uart0_pads));
+}
+
+int board_early_init_f(void)
+{
+	sc_pm_clock_rate_t rate = SC_80MHZ;
+	int ret;
+
+	/* Set UART0 clock root to 80 MHz */
+	ret = sc_pm_setup_uart(SC_R_UART_0, rate);
+	if (ret)
+		return ret;
+
+	setup_iomux_uart();
+
+	return 0;
+}
+
+#ifdef CONFIG_FSL_ESDHC
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(4, 22)
+
+#ifndef CONFIG_SPL_BUILD
+static struct fsl_esdhc_cfg usdhc_cfg[CONFIG_SYS_FSL_USDHC_NUM] = {
+	{USDHC1_BASE_ADDR, 0, 8},
+	{USDHC2_BASE_ADDR, 0, 4},
+};
+
+static iomux_cfg_t emmc0[] = {
+	SC_P_EMMC0_CLK | MUX_PAD_CTRL(ESDHC_CLK_PAD_CTRL),
+	SC_P_EMMC0_CMD | MUX_PAD_CTRL(ESDHC_PAD_CTRL),
+	SC_P_EMMC0_DATA0 | MUX_PAD_CTRL(ESDHC_PAD_CTRL),
+	SC_P_EMMC0_DATA1 | MUX_PAD_CTRL(ESDHC_PAD_CTRL),
+	SC_P_EMMC0_DATA2 | MUX_PAD_CTRL(ESDHC_PAD_CTRL),
+	SC_P_EMMC0_DATA3 | MUX_PAD_CTRL(ESDHC_PAD_CTRL),
+	SC_P_EMMC0_DATA4 | MUX_PAD_CTRL(ESDHC_PAD_CTRL),
+	SC_P_EMMC0_DATA5 | MUX_PAD_CTRL(ESDHC_PAD_CTRL),
+	SC_P_EMMC0_DATA6 | MUX_PAD_CTRL(ESDHC_PAD_CTRL),
+	SC_P_EMMC0_DATA7 | MUX_PAD_CTRL(ESDHC_PAD_CTRL),
+	SC_P_EMMC0_STROBE | MUX_PAD_CTRL(ESDHC_PAD_CTRL),
+};
+
+static iomux_cfg_t usdhc1_sd[] = {
+	SC_P_USDHC1_CLK | MUX_PAD_CTRL(ESDHC_CLK_PAD_CTRL),
+	SC_P_USDHC1_CMD | MUX_PAD_CTRL(ESDHC_PAD_CTRL),
+	SC_P_USDHC1_DATA0 | MUX_PAD_CTRL(ESDHC_PAD_CTRL),
+	SC_P_USDHC1_DATA1 | MUX_PAD_CTRL(ESDHC_PAD_CTRL),
+	SC_P_USDHC1_DATA2 | MUX_PAD_CTRL(ESDHC_PAD_CTRL),
+	SC_P_USDHC1_DATA3 | MUX_PAD_CTRL(ESDHC_PAD_CTRL),
+	SC_P_USDHC1_WP    | MUX_PAD_CTRL(ESDHC_PAD_CTRL), /* Mux for WP */
+	SC_P_USDHC1_CD_B  | MUX_MODE_ALT(4) | MUX_PAD_CTRL(ESDHC_PAD_CTRL), /* Mux for CD,  GPIO4 IO22 */
+	SC_P_USDHC1_RESET_B | MUX_PAD_CTRL(ESDHC_PAD_CTRL),
+	SC_P_USDHC1_VSELECT | MUX_PAD_CTRL(ESDHC_PAD_CTRL),
+};
+
+int board_mmc_init(bd_t *bis)
+{
+	int i, ret;
+	struct power_domain pd;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc1                    USDHC2
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			if (!power_domain_lookup_name("conn_sdhc0", &pd))
+				power_domain_on(&pd);
+			imx8_iomux_setup_multiple_pads(emmc0, ARRAY_SIZE(emmc0));
+			init_clk_usdhc(0);
+			usdhc_cfg[i].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			break;
+		case 1:
+			if (!power_domain_lookup_name("conn_sdhc1", &pd))
+				power_domain_on(&pd);
+			imx8_iomux_setup_multiple_pads(usdhc1_sd, ARRAY_SIZE(usdhc1_sd));
+			init_clk_usdhc(1);
+			usdhc_cfg[i].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			gpio_request(USDHC1_CD_GPIO, "sd1_cd");
+			gpio_direction_input(USDHC1_CD_GPIO);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return 0;
+		}
+		ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+		if (ret) {
+			printf("Warning: failed to initialize mmc dev %d\n", i);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = 1; /* eMMC */
+		break;
+	case USDHC2_BASE_ADDR:
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+		break;
+	}
+
+	return ret;
+}
+
+#endif /* CONFIG_SPL_BUILD */
+#endif /* CONFIG_FSL_ESDHC */
+
+
+#ifdef CONFIG_FEC_MXC
+#include <miiphy.h>
+
+static iomux_cfg_t pad_enet_resetn[] = {
+	/* Shared MDIO */
+	SC_P_QSPI0B_DQS   | MUX_MODE_ALT(4) | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL), /* Mux for RESET,  GPIO3 IO22 */
+	SC_P_QSPI0B_SS0_B | MUX_MODE_ALT(4) | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL), /* Mux for RESET,  GPIO3 IO23 */
+};
+
+static iomux_cfg_t pad_enet_mdio[] = {
+	/* Shared MDIO */
+	SC_P_ENET0_MDC | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ENET0_MDIO | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+};
+
+static iomux_cfg_t pad_enet1[] = {
+	SC_P_SPDIF0_TX | MUX_MODE_ALT(3) | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_SPDIF0_RX | MUX_MODE_ALT(3) | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ESAI0_TX3_RX2 | MUX_MODE_ALT(3) | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ESAI0_TX2_RX3 | MUX_MODE_ALT(3) | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ESAI0_TX1 | MUX_MODE_ALT(3) | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ESAI0_TX0 | MUX_MODE_ALT(3) | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ESAI0_SCKR | MUX_MODE_ALT(3) | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ESAI0_TX4_RX1 | MUX_MODE_ALT(3) | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ESAI0_TX5_RX0 | MUX_MODE_ALT(3) | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ESAI0_FST  | MUX_MODE_ALT(3) | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ESAI0_SCKT | MUX_MODE_ALT(3) | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ESAI0_FSR  | MUX_MODE_ALT(3) | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+};
+
+static iomux_cfg_t pad_enet0[] = {
+	SC_P_ENET0_RGMII_RX_CTL | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ENET0_RGMII_RXD0 | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ENET0_RGMII_RXD1 | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ENET0_RGMII_RXD2 | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ENET0_RGMII_RXD3 | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ENET0_RGMII_RXC | MUX_PAD_CTRL(ENET_INPUT_PAD_CTRL),
+	SC_P_ENET0_RGMII_TX_CTL | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ENET0_RGMII_TXD0 | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ENET0_RGMII_TXD1 | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ENET0_RGMII_TXD2 | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ENET0_RGMII_TXD3 | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+	SC_P_ENET0_RGMII_TXC | MUX_PAD_CTRL(ENET_NORMAL_PAD_CTRL),
+};
+
+static void setup_iomux_fec(void)
+{
+	imx8_iomux_setup_multiple_pads(pad_enet_resetn, ARRAY_SIZE(pad_enet_resetn));
+	imx8_iomux_setup_multiple_pads(pad_enet_mdio, ARRAY_SIZE(pad_enet_mdio));
+	imx8_iomux_setup_multiple_pads(pad_enet0, ARRAY_SIZE(pad_enet0));
+	imx8_iomux_setup_multiple_pads(pad_enet1, ARRAY_SIZE(pad_enet1));
+}
+
+static void set_gpio_enet_phy_resetn(const char *gpio_name, const char *phy_name)
+{
+	struct gpio_desc desc_enet;
+	int ret;
+
+	ret = dm_gpio_lookup_name(gpio_name, &desc_enet);
+	if (ret) {
+		printf("dm_gpio_lookup_name failed with error: %d for %s \n", ret, gpio_name);
+		return;
+	}
+
+	ret = dm_gpio_request(&desc_enet, phy_name);
+	if (ret) {
+		printf("dm_gpio_request failed with error: %d for %s \n", ret, gpio_name);
+		return;
+	}
+
+	dm_gpio_set_dir_flags(&desc_enet, GPIOD_IS_OUT);
+	dm_gpio_set_value(&desc_enet, 0);
+	udelay(50);
+	dm_gpio_set_value(&desc_enet, 1);
+
+	/* The board has a long delay for this reset to become stable */
+	mdelay(200);
+}
+
+/*
+ * cl_som_imx8x_handle_mac_address() - set Ethernet MAC address environment.
+ *
+ * @env_var: MAC address environment variable
+ * @eeprom_bus: I2C bus of the environment EEPROM
+ * @eeprom_field_mac_addr: EEPROM field name of the MAC address 
+ *
+ * @return: 0 on success, < 0 on failure
+ */
+static int cl_som_imx8x_handle_mac_address(const char *env_var, uint eeprom_bus,
+					   uchar mac_index,
+					   char *eeprom_field_mac_addr)
+{
+	int ret;
+	unsigned char enetaddr[7];
+
+	ret = eth_env_get_enetaddr(env_var, enetaddr);
+	if (ret)
+		return 0;
+
+	if (cl_som_imx8x_layout.data) {
+		ret = cl_som_imx8x_layout.read(&cl_som_imx8x_layout,
+					       eeprom_field_mac_addr, enetaddr,
+					       sizeof(enetaddr));
+	}
+
+	if (ret) {
+		printf("%s: Failed to read MAC address from EEPROM. ret=%d\n",
+		       __func__, ret);
+		return ret;
+	}
+
+	ret = is_valid_ethaddr(enetaddr);
+	enetaddr[6]=0;
+	if (!ret) {
+		printf("%s: Read invalid MAC address from EEPROM. ret=%d %s\n",
+		       __func__, ret, enetaddr);
+		return -1;
+	}
+
+	return eth_env_set_enetaddr(env_var, enetaddr);
+}
+
+static void setup_fec_mac(void) {
+	if (cl_som_imx8x_handle_mac_address("ethaddr",
+					    CONFIG_SYS_I2C_EEPROM_BUS,
+					    IMX_FEC1_PHYADDR,
+					    "1st MAC Address"))
+		printf("No MAC address found for %s\n", "primary NIC");
+	if (cl_som_imx8x_handle_mac_address("eth1addr",
+					    CONFIG_SYS_I2C_EEPROM_BUS,
+					    IMX_FEC0_PHYADDR,
+					    "2nd MAC Address"))
+		printf("No MAC address found for %s\n", "secondary NIC");
+}
+
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+	struct power_domain pd;
+
+	printf("[%s] %d\n", __func__, __LINE__);
+
+	if (!power_domain_lookup_name("lsio_flexspi1", &pd))
+		power_domain_on(&pd);
+	else
+		printf("power domain lookup error: %s \n", "lsio_flexspi1");
+
+	if (!power_domain_lookup_name("conn_enet0", &pd))
+		power_domain_on(&pd);
+	else
+		printf("power domain lookup error: %s \n", "conn_enet0");
+
+	if (!power_domain_lookup_name("conn_enet1", &pd))
+		power_domain_on(&pd);
+	else
+		printf("power domain lookup error: %s \n", "conn_enet1");
+
+	setup_iomux_fec();
+
+	ret = fecmxc_initialize_multi(bis, 1, IMX_FEC0_PHYADDR, IMX_FEC0_BASE);
+	if (ret)
+		printf("FEC%d MXC: %s:failed\n", 0, __func__);
+
+	ret = fecmxc_initialize_multi(bis, 0, IMX_FEC1_PHYADDR, IMX_FEC1_BASE);
+	if (ret)
+		printf("FEC%d MXC: %s:failed\n", 1, __func__);
+
+	return ret;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);
+
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x00);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x82ee);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_MXC_GPIO
+static void board_gpio_init(void)
+{
+	/* Init peripheral GPIO here */
+}
+#endif
+
+int checkboard(void)
+{
+	puts("Board: CL-SOM-iMX8X\n");
+
+	print_bootinfo();
+
+	return 0;
+}
+
+int board_init(void)
+{
+#ifdef CONFIG_MXC_GPIO
+	board_gpio_init();
+#endif
+
+#ifdef CONFIG_FEC_MXC
+	set_gpio_enet_phy_resetn("gpio3_23", "enet0_reset");
+	set_gpio_enet_phy_resetn("gpio3_22", "enet1_reset");
+#endif
+	return 0;
+}
+
+void board_quiesce_devices()
+{
+	const char *power_on_devices[] = {
+		"dma_lpuart0"
+	};
+
+	power_off_pd_devices(power_on_devices, ARRAY_SIZE(power_on_devices));
+}
+
+void detail_board_ddr_info(void)
+{
+	puts("\nDDR    ");
+}
+
+/*
+ * Board specific reset that is system reset.
+ */
+void reset_cpu(ulong addr)
+{
+	sc_pm_reboot(-1, SC_PM_RESET_TYPE_COLD);
+	while(1);
+}
+
+#ifdef CONFIG_OF_BOARD_SETUP
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	return 0;
+}
+#endif
+
+int board_mmc_get_env_dev(int devno)
+{
+	return devno;
+}
+
+int board_late_init(void)
+{
+	int ret;
+
+	/* Initialize the CL-SOM-iMX8X EEPROM layout structure */
+	ret = cl_eeprom_layout_setup(&cl_som_imx8x_layout,
+				     cl_som_imx8x_eeprom_buf,
+				     LAYOUT_VERSION_AUTODETECT,
+				     CONFIG_SYS_I2C_EEPROM_BUS,
+				     CONFIG_SYS_I2C_EEPROM_ADDR);
+	if (ret)
+		printf("%s: failed to Initialize the CL-SOM-iMX8X EEPROM "
+		       "layout structure. ret=%d\n", __func__, ret);
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec_mac();
+#endif
+
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+	env_set("board_name", "CL-SOM-iMX8X");
+	env_set("board_rev", "1.0");
+#endif
+
+#ifdef CONFIG_AHAB_BOOT
+	env_set("sec_boot", "yes");
+#else
+	env_set("sec_boot", "no");
+#endif
+
+	return 0;
+}
diff --git a/board/compulab/cl-som-imx8x/cl-som-imx8x.cfg b/board/compulab/cl-som-imx8x/cl-som-imx8x.cfg
new file mode 100644
index 0000000000..03c6858b9a
--- /dev/null
+++ b/board/compulab/cl-som-imx8x/cl-som-imx8x.cfg
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2021 CompuLab
+ *
+ * Refer doc/README.imx8image for more details about how-to configure
+ * and create imx8image boot image
+ */
+
+#define __ASSEMBLY__
+
+/* Boot from SD, sector size 0x400 */
+BOOT_FROM SD 0x400
+/* SoC type IMX8QX */
+SOC_TYPE IMX8QX
diff --git a/board/compulab/cl-som-imx8x/spl.c b/board/compulab/cl-som-imx8x/spl.c
new file mode 100644
index 0000000000..8669aa5b89
--- /dev/null
+++ b/board/compulab/cl-som-imx8x/spl.c
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2019 CompuLab
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <spl.h>
+#include <dm/uclass.h>
+#include <dm/device.h>
+#include <dm/uclass-internal.h>
+#include <dm/device-internal.h>
+#include <dm/lists.h>
+#include <bootm.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void spl_board_init(void)
+{
+	struct udevice *dev;
+
+	uclass_find_first_device(UCLASS_MISC, &dev);
+
+	for (; dev; uclass_find_next_device(&dev)) {
+		if (device_probe(dev))
+			continue;
+	}
+
+	board_early_init_f();
+
+	timer_init();
+
+#ifdef CONFIG_SPL_SERIAL_SUPPORT
+	preloader_console_init();
+
+	puts("Normal Boot\n");
+#endif
+}
+
+void spl_board_prepare_for_boot(void)
+{
+	board_quiesce_devices();
+}
+
+void board_init_f(ulong dummy)
+{
+	/* Clear the BSS. */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+	arch_cpu_init();
+
+	board_init_r(NULL, 0);
+}
diff --git a/configs/cl-som-imx8x_defconfig b/configs/cl-som-imx8x_defconfig
new file mode 100644
index 0000000000..45ba29d3e9
--- /dev/null
+++ b/configs/cl-som-imx8x_defconfig
@@ -0,0 +1,168 @@
+CONFIG_ARM=y
+CONFIG_SPL_SYS_ICACHE_OFF=y
+CONFIG_SPL_SYS_DCACHE_OFF=y
+CONFIG_ARCH_IMX8=y
+CONFIG_SYS_TEXT_BASE=0x80020000
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_SYS_MALLOC_F_LEN=0x8000
+CONFIG_ENV_SIZE=0x2000
+CONFIG_ENV_SECT_SIZE=0x1000
+CONFIG_ENV_OFFSET=0x400000
+CONFIG_DM_GPIO=y
+CONFIG_SPL_DM_SPI=y
+CONFIG_BOOTAUX_RESERVED_MEM_BASE=0x88000000
+CONFIG_BOOTAUX_RESERVED_MEM_SIZE=0x08000000
+CONFIG_SPL_LOAD_IMX_CONTAINER=y
+CONFIG_TARGET_CL_SOM_IMX8X=y
+CONFIG_SNVS_SEC_SC=y
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_DRIVERS_MISC_SUPPORT=y
+CONFIG_SPL=y
+CONFIG_SPL_SPI_FLASH_SUPPORT=y
+CONFIG_SPL_SPI_SUPPORT=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_IMX_VSERVICE_SHARED_BUFFER=0x90400000
+CONFIG_SPL_TEXT_BASE=0x100000
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_OF_SYSTEM_SETUP=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/compulab/cl-som-imx8x/cl-som-imx8x.cfg"
+CONFIG_QSPI_BOOT=y
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_STDIO_DEREGISTER=y
+CONFIG_LOG=y
+CONFIG_SPL_BOARD_INIT=y
+CONFIG_SPL_SEPARATE_BSS=y
+CONFIG_SPL_NOR_SUPPORT=y
+CONFIG_SPL_POWER_SUPPORT=y
+CONFIG_SPL_POWER_DOMAIN=y
+CONFIG_SPL_SPI_LOAD=y
+CONFIG_SYS_SPI_U_BOOT_OFFS=0x200000
+CONFIG_SPL_USB_GADGET=y
+CONFIG_SPL_USB_SDP_SUPPORT=y
+CONFIG_SPL_SDP_USB_DEV=1
+CONFIG_SPL_WATCHDOG_SUPPORT=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="CL-SOM-iMX8X # "
+CONFIG_CMD_CPU=y
+# CONFIG_BOOTM_NETBSD is not set
+# CONFIG_CMD_IMPORTENV is not set
+CONFIG_CMD_EEPROM=y
+CONFIG_CMD_EEPROM_LAYOUT=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_CLK=y
+CONFIG_CMD_DM=y
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_GPT=y
+CONFIG_CMD_GPT_RENAME=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+# CONFIG_SPL_DOS_PARTITION is not set
+# CONFIG_SPL_EFI_PARTITION is not set
+CONFIG_SPL_OF_CONTROL=y
+CONFIG_DEFAULT_DEVICE_TREE="cl-som-imx8x"
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_SPL_DM=y
+CONFIG_SPL_DM_SEQ_ALIAS=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_SPL_CLK=y
+CONFIG_CLK_IMX8=y
+CONFIG_CPU=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x82800000
+CONFIG_FASTBOOT_BUF_SIZE=0x40000000
+CONFIG_FASTBOOT_USB_DEV=1
+# CONFIG_FASTBOOT_UUU_SUPPORT is not set
+CONFIG_MXC_GPIO=y
+CONFIG_DM_PCA953X=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_IMX_LPI2C=y
+CONFIG_SYS_I2C_IMX_VIRT_I2C=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_I2C_MUX_IMX_VIRT=y
+CONFIG_I2C_EEPROM=y
+CONFIG_SYS_I2C_EEPROM_ADDR=0x50
+CONFIG_SYS_I2C_EEPROM_BUS=1
+CONFIG_DM_MMC=y
+CONFIG_SUPPORT_EMMC_BOOT=y
+CONFIG_MMC_IO_VOLTAGE=y
+CONFIG_MMC_UHS_SUPPORT=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_FSL_USDHC=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SF_DEFAULT_MODE=0x3
+CONFIG_SF_DEFAULT_SPEED=133000000
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_PHYLIB=y
+CONFIG_PHY_ADDR_ENABLE=y
+CONFIG_PHY_ATHEROS=y
+CONFIG_DM_ETH=y
+CONFIG_PHY_GIGE=y
+CONFIG_FEC_MXC_SHARE_MDIO=y
+CONFIG_FEC_MXC_MDIO_BASE=0x5B040000
+CONFIG_FEC_MXC=y
+CONFIG_MII=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PHY=y
+CONFIG_SPL_PHY=y
+CONFIG_CDNS3_USB_PHY=y
+CONFIG_PINCTRL=y
+CONFIG_SPL_PINCTRL=y
+CONFIG_PINCTRL_IMX8=y
+CONFIG_POWER_DOMAIN=y
+CONFIG_IMX8_POWER_DOMAIN=y
+CONFIG_DM_REGULATOR=y
+CONFIG_SPL_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_SPL_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_SERIAL=y
+CONFIG_FSL_LPUART=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_NXP_FSPI=y
+CONFIG_FSL_FSPI=y
+CONFIG_DM_THERMAL=y
+CONFIG_IMX_SCU_THERMAL=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_SPL_DM_USB_GADGET=y
+CONFIG_USB_XHCI_HCD=y
+# CONFIG_USB_EHCI_HCD is not set
+CONFIG_USB_CDNS3=y
+CONFIG_USB_CDNS3_GADGET=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="FSL"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0525
+CONFIG_USB_GADGET_PRODUCT_NUM=0xa4a5
+CONFIG_CI_UDC=y
+CONFIG_SDP_LOADADDR=0x80400000
+CONFIG_USB_PORT_AUTO=y
+CONFIG_DM_VIDEO=y
+CONFIG_SYS_WHITE_ON_BLACK=y
+CONFIG_VIDEO_IMXDPUV1=y
+CONFIG_VIDEO_IMX8_LVDS=y
+CONFIG_VIDEO_IT6263_BRIDGE=y
+CONFIG_FAT_WRITE=y
+CONFIG_PANIC_HANG=y
+CONFIG_SPL_TINY_MEMSET=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+# CONFIG_EFI_LOADER is not set
diff --git a/include/configs/cl-som-imx8x.h b/include/configs/cl-som-imx8x.h
new file mode 100644
index 0000000000..1b9bd50c01
--- /dev/null
+++ b/include/configs/cl-som-imx8x.h
@@ -0,0 +1,267 @@
+/*
+ * Copyright 2019 CompuLab
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __CL_SOM_IMX8X_H
+#define __CL_SOM_IMX8X_H
+
+#include <linux/sizes.h>
+#include <asm/arch/imx-regs.h>
+
+#include "imx_env.h"
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SPL_MAX_SIZE		(192 * 1024)
+#define CONFIG_SYS_MONITOR_LEN		(1024 * 1024)
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR		0x1040 /* (32K + 2Mb)/sector_size */
+
+/*
+ * 0x08081000 - 0x08180FFF is for m4_0 xip image,
+  * So 3rd container image may start from 0x8181000
+ */
+#define CONFIG_SYS_UBOOT_BASE 0x08181000
+#define CONFIG_SYS_MMCSD_FS_BOOT_PARTITION		0
+
+#define CONFIG_SPL_LDSCRIPT		"arch/arm/cpu/armv8/u-boot-spl.lds"
+#define CONFIG_SPL_STACK		0x013fff0
+#define CONFIG_SPL_BSS_START_ADDR      0x00130000
+#define CONFIG_SPL_BSS_MAX_SIZE        0x1000
+#define CONFIG_SYS_SPL_MALLOC_START    0x82200000
+#define CONFIG_SYS_SPL_MALLOC_SIZE     0x80000
+#define CONFIG_SERIAL_LPUART_BASE      0x5a060000
+#define CONFIG_SYS_DCACHE_OFF
+#define CONFIG_MALLOC_F_ADDR		0x00138000 /* malloc f used before GD_FLG_FULL_MALLOC_INIT set */
+
+#define CONFIG_SPL_RAW_IMAGE_ARM_TRUSTED_FIRMWARE
+
+#define CONFIG_SPL_ABORT_ON_RAW_IMAGE /* For RAW image gives a error info not panic */
+
+#define CONFIG_OF_EMBED
+#define CONFIG_ATF_TEXT_BASE 0x80000000
+#define CONFIG_SYS_ATF_START 0x80000000
+/* #define CONFIG_FIT */
+
+/* Since the SPL runs before ATF, MU1 will not be started yet, so use MU0 */
+#define SC_IPC_CH			SC_IPC_AP_CH0
+
+#endif
+
+#ifndef CONFIG_SPL_SPI_SUPPORT
+#define CONFIG_SPL_SPI_SUPPORT 1
+#endif
+
+#define CONFIG_REMAKE_ELF
+
+#define CONFIG_BOARD_EARLY_INIT_F
+
+#define CONFIG_CMD_READ
+
+/* Flat Device Tree Definitions */
+#define CONFIG_OF_BOARD_SETUP
+
+#undef CONFIG_CMD_EXPORTENV
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_CRC32
+#undef CONFIG_BOOTM_NETBSD
+
+#define CONFIG_SYS_FSL_ESDHC_ADDR       0
+#define USDHC1_BASE_ADDR                0x5B010000
+#define USDHC2_BASE_ADDR                0x5B020000
+
+#define CONFIG_ENV_OVERWRITE
+
+
+#define CONFIG_FSL_HSIO
+#ifdef CONFIG_FSL_HSIO
+#define CONFIG_PCIE_IMX
+#define CONFIG_PCIE_IMX8X
+#define CONFIG_PCI_SCAN_SHOW
+#endif
+
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+
+#define CONFIG_FEC_XCV_TYPE             RGMII
+#define FEC_QUIRK_ENET_MAC
+
+/* ENET0 connects AR8031 on CPU board, ENET1 connects to base board and MUX with ESAI, default is ESAI */
+#define CONFIG_FEC_ENET_DEV 1
+
+#define IMX_FEC0_BASE			0x5B040000
+#define IMX_FEC1_BASE			0x5B050000
+
+#define IMX_FEC0_PHYADDR		1
+#define IMX_FEC1_PHYADDR		0
+
+#if (CONFIG_FEC_ENET_DEV == 0)
+#define CONFIG_FEC_MXC_PHYADDR          IMX_FEC0_PHYADDR
+#define CONFIG_ETHPRIME                 "eth0"
+#elif (CONFIG_FEC_ENET_DEV == 1)
+#define CONFIG_FEC_MXC_PHYADDR          IMX_FEC1_PHYADDR
+#define CONFIG_ETHPRIME                 "eth1"
+#endif
+
+/* ENET0 MDIO are shared */
+#define CONFIG_FEC_MXC_MDIO_BASE	0x5B040000
+
+#ifdef CONFIG_AHAB_BOOT
+#define AHAB_ENV "sec_boot=yes\0"
+#else
+#define AHAB_ENV "sec_boot=no\0"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS        \
+    AHAB_ENV \
+    "boot_emmc=setenv mmcdev 0; setenv mmcroot /dev/mmcblk0p2; " \
+        "run mmcargs; run load_mmc && run boot_os\0" \
+    "boot_os=booti ${loadaddr} - ${fdt_addr}\0" \
+    "boot_sd=setenv mmcdev 1; mmc dev ${mmcdev} && " \
+        "setenv mmcroot /dev/mmcblk1p2 && run mmcargs && " \
+        "run load_mmc && run boot_os\0" \
+    "boot_sd_script=setenv mmcdev 1; mmc dev ${mmcdev} && " \
+        "if run loadbootscript; then " \
+            "run bootscript; " \
+        "fi\0" \
+    "load_mmc=fatload mmc ${mmcdev} ${loadaddr} ${image} && " \
+        "fatload mmc ${mmcdev} ${fdt_addr} ${fdt_file}\0" \
+    "script=boot.scr\0" \
+    "image=Image\0" \
+    "panel=NULL\0" \
+    "console=ttyLP0,115200 earlycon=lpuart32,0x5a060000,115200\0" \
+    "fdt_addr=0x83000000\0"            \
+    "fdt_high=0xffffffffffffffff\0"        \
+    "fdt_file=sb-imx8x.dtb\0" \
+    "initrd_addr=0x83100000\0" \
+    "initrd_high=0xffffffffffffffff\0" \
+    "mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+    "mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+    "mmcautodetect=yes\0" \
+    "mmcargs=setenv bootargs console=${console} " \
+        "root=/dev/mmcblk${mmcdev}p2 rootwait rw\0" \
+    "loadbootscript=load mmc ${mmcdev}:${mmcpart} ${loadaddr} " \
+        "${script};\0" \
+    "bootscript=echo Running bootscript ...; " \
+        "source\0" \
+    "autoload=off\0"
+
+#define CONFIG_BOOTCOMMAND \
+    "echo SD boot attempt ... && run boot_sd_script || run boot_sd || " \
+        "echo eMMC boot attempt ... && run boot_emmc "
+
+/* Link Definitions */
+#define CONFIG_LOADADDR			0x80280000
+
+#define CONFIG_SYS_LOAD_ADDR           CONFIG_LOADADDR
+
+#define CONFIG_SYS_INIT_SP_ADDR         0x80200000
+
+
+/* Default environment is in SD */
+#ifdef CONFIG_QSPI_BOOT
+#undef CONFIG_ENV_OFFSET
+#define CONFIG_ENV_OFFSET       (FSL_FSPI_FLASH_SIZE - (2 * CONFIG_ENV_SIZE)) /* Should be aligned 0x10000 */
+#define CONFIG_ENV_SPI_BUS	CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS	CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE	CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ	CONFIG_SF_DEFAULT_SPEED
+#else
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#endif
+
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+
+/* On LPDDR4 board, USDHC1 is for eMMC, USDHC2 is for SD on CPU board
+  */
+#define CONFIG_SYS_MMC_ENV_DEV		1   /* USDHC2 */
+#define CONFIG_MMCROOT			"/dev/mmcblk1p2"  /* USDHC2 */
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		((CONFIG_ENV_SIZE + (32*1024)) * 1024)
+
+#define CONFIG_SYS_SDRAM_BASE		0x80000000
+#define PHYS_SDRAM_1			0x80000000
+#define PHYS_SDRAM_2			0x880000000
+#define PHYS_SDRAM_1_SIZE		0x80000000	/* 2 GB */
+/* LPDDR4 board total DDR is 3GB */
+#define PHYS_SDRAM_2_SIZE		0x0			/* 0 GB */
+
+#define CONFIG_SYS_MEMTEST_START    0xA0000000
+#define CONFIG_SYS_MEMTEST_END      (CONFIG_SYS_MEMTEST_START + (PHYS_SDRAM_1_SIZE >> 2))
+
+/* Serial */
+#define CONFIG_BAUDRATE			115200
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_PROMPT_HUSH_PS2     "> "
+#define CONFIG_SYS_CBSIZE              2048
+#define CONFIG_SYS_MAXARGS             64
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY		8000000	/* 8MHz */
+
+#ifndef CONFIG_DM_PCA953X
+#define CONFIG_PCA953X
+#define CONFIG_CMD_PCA953X
+#define CONFIG_CMD_PCA953X_INFO
+#endif
+
+/* MT35XU512ABA1G12 has only one Die, so QSPI0 B won't work */
+#ifdef CONFIG_FSL_FSPI
+#define CONFIG_SF_DEFAULT_BUS		0
+#define CONFIG_SF_DEFAULT_CS		0
+#define FSL_FSPI_FLASH_SIZE		SZ_2M
+#define FSL_FSPI_FLASH_NUM		1
+#define FSPI0_BASE_ADDR			0x5d120000
+#define FSPI0_AMBA_BASE			0
+#define CONFIG_SYS_FSL_FSPI_AHB
+#endif
+
+/*#define CONFIG_SERIAL_TAG*/
+
+/* USB Config */
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_USB_EHCI_HCD
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#define CONFIG_USBD_HS
+
+#define CONFIG_CMD_USB_MASS_STORAGE
+#define CONFIG_USB_GADGET_MASS_STORAGE
+#define CONFIG_USB_FUNCTION_MASS_STORAGE
+
+#endif /* !CONFIG_SPL_BUILD */
+
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+
+/* USB OTG controller configs */
+#ifdef CONFIG_USB_EHCI_HCD
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC		(PORT_PTS_UTMI | PORT_PTS_PTW)
+#endif
+
+/* Framebuffer */
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_IMXDPUV1
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_IMX_VIDEO_SKIP
+#endif
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "imx8qxp_mek_android.h"
+#elif defined (CONFIG_ANDROID_AUTO_SUPPORT)
+#include "imx8qxp_mek_android_auto.h"
+#endif
+
+#endif /* __CL_SOM_IMX8X_H */
-- 
2.11.0

